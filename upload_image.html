<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ユーザー画像アップロード</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムスタイル */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        #editor-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 900px;
            width: 100%;
            background: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        #pixelCanvas {
            border: 1px solid #d1d5db;
            /* 描画機能がないため、カーソルはデフォルトに戻す */
            cursor: default;
            touch-action: none;
            background-color: #ffffff;
            /* 250x250は小さいため、少し大きく表示する */
            width: 500px;
            height: 500px;
            image-rendering: pixelated;
            /* 拡大表示してもぼやけないようにする */
        }

        /* ツールボタンの共通スタイル */
        .tool-button {
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        .tool-button:hover:not(:disabled) {
            opacity: 0.8;
        }

        .tool-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        .tool-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* モバイル向けレイアウト調整 */
        @media (min-width: 1024px) {
            #editor-container {
                flex-direction: row;
                align-items: flex-start;
            }
        }
    </style>
</head>

<body>

    <!-- Cropping Modal -->
    <div id="cropperModal"
        class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-lg">
            <h3 class="text-xl font-bold mb-4 text-gray-800">画像を正方形にクロップ</h3>
            <p class="text-gray-700 mb-4 text-sm">クロップ領域（白い枠）をドラッグして、250x250マスに変換したい領域を指定してください。</p>

            <div class="flex justify-center mb-6">
                <!-- Cropper Canvas (Preview) -->
                <canvas id="cropperPreviewCanvas" width="300" height="300"
                    class="border-2 border-dashed border-indigo-300 rounded-lg cursor-grab"></canvas>
            </div>

            <div class="flex justify-end gap-3">
                <button id="cancelCropButton"
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">キャンセル</button>
                <button id="confirmCropButton"
                    class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition tool-button">クロップして使用</button>
            </div>
        </div>
    </div>


    <div id="editor-container">
        <!-- コントロールパネル -->
        <div class="lg:w-1/3 w-full p-4 bg-gray-50 rounded-xl flex flex-col gap-6 order-2 lg:order-1">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">ユーザー画像アップロード</h2>

            <!-- 1. 画像アップロード機能 -->
            <div class="mt-2">
                <h3 class="text-lg font-semibold text-gray-700 mb-2">画像ファイルの選択</h3>
                <input type="file" id="imageUploader" accept="image/*" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-indigo-50 file:text-indigo-700
                    hover:file:bg-indigo-100
                " />
                <p class="text-sm text-gray-500 mt-2">※ 正方形でない画像は、アップロード後にクロップエリアを指定できます。</p>
            </div>

            <!-- 2. Utility Actions Group (左右反転とデータ送信) -->
            <div class="flex gap-4 items-center pt-2 border-t border-gray-200">
                <!-- 左右反転ボタン (小さくして上に配置) -->
                <button id="flipHorizontalButton"
                    class="tool-button p-3 w-12 h-12 flex-shrink-0 bg-purple-600 text-white rounded-lg shadow-lg hover:bg-purple-700 transition"
                    title="画像を左右反転">
                    <!-- SVG for Horizontal Flip -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m3 12 18 0" />
                        <path d="m6 15 3-3-3-3" />
                        <path d="m18 9-3 3 3 3" />
                    </svg>
                </button>

                <!-- データ送信機能 (サイズを調整し、横に配置) -->
                <div class="flex-grow">
                    <button id="sendDataButton"
                        class="tool-button bg-indigo-600 text-white py-3 rounded-lg shadow-lg w-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 5V19" />
                            <path d="m18 13-6 6-6-6" />
                        </svg>
                        GASにデータを送信
                    </button>
                </div>
            </div>

            <!-- 3. メッセージ表示エリア -->
            <div id="messageBox" class="text-sm p-3 rounded-lg text-center hidden"></div>

        </div>

        <!-- キャンバスエリア -->
        <div class="lg:w-2/3 w-full flex justify-center items-center order-1 lg:order-2">
            <!-- プレビュー表示エリア (常に250x250のピクセルアートが表示される) -->
            <canvas id="pixelCanvas" width="250" height="250"></canvas>
        </div>
    </div>

    <script>
        // --- 設定 ---
        const CANVAS_SIZE = 250;
        const FIXED_GRID_DIMENSION = 250;
        // GASエンドポイント。末尾の /exec はそのまま
        const GAS_ENDPOINT = "https://script.google.com/macros/s/AKfycbwDKI_-L5Asg5e4wP_vkyWkjop1VCDaFRFgY7S_J7xV5ws0o60DZAr7tWyE0BxguO3v1Q/exec";

        // --- DOM要素 ---
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const imageUploader = document.getElementById('imageUploader');
        const flipHorizontalButton = document.getElementById('flipHorizontalButton');
        const sendDataButton = document.getElementById('sendDataButton');
        const messageBox = document.getElementById('messageBox');

        // クロップモーダル要素
        const cropperModal = document.getElementById('cropperModal');
        const cropperPreviewCanvas = document.getElementById('cropperPreviewCanvas');
        const cropperPreviewCtx = cropperPreviewCanvas.getContext('2d');
        const confirmCropButton = document.getElementById('confirmCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // --- 状態 ---
        const gridDimension = FIXED_GRID_DIMENSION;
        const pixelSize = CANVAS_SIZE / gridDimension;
        let pixelMap = new Map(); // ピクセルデータを格納するMap: { "x,y": "color" } 形式
        let currentImageToCrop = null; // クロップ待ちの画像オブジェクト

        // Cropper State (ドラッグ制御用)
        let cropState = {
            originalCropX: 0,
            originalCropY: 0,
            originalCropSize: 0,
            displayCropX: 0,
            displayCropY: 0,
            displayCropSize: 0,
            imgDraw: { x: 0, y: 0, w: 0, h: 0, ratio: 1 },
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            dragStartCropX: 0,
            dragStartCropY: 0,
        };

        // ----------------------------------------------------
        // メッセージ表示機能
        // ----------------------------------------------------
        function showMessage(text, type = 'info') {
            messageBox.textContent = text;
            messageBox.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');

            if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-700');
            } else if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-700');
            } else {
                messageBox.classList.add('bg-blue-100', 'text-blue-700');
            }
            // 3秒後にメッセージを非表示にする (エラーは残す)
            if (type !== 'error') {
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 5000); // 5秒間に延長
            }
        }

        // ----------------------------------------------------
        // ユーティリティ関数
        // ----------------------------------------------------

        /**
         * ピクセルデータ全体を再描画します。
         */
        function redrawCanvas() {
            // キャンバスを白でクリア
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // 1. ピクセルを描画
            for (const [key, color] of pixelMap.entries()) {
                const [x, y] = key.split(',').map(Number);
                ctx.fillStyle = color;
                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }

        /**
         * 実際のピクセル化処理。画像をクロップ＆250x250に変換してpixelMapに格納します。
         * @param {HTMLImageElement} img - 処理する画像オブジェクト
         */
        function pixelateImage(img) {
            // 1. 一時キャンバスを作成して、画像をクロップ＆リサイズして描画
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = CANVAS_SIZE;
            tempCanvas.height = CANVAS_SIZE;

            // cropStateからクロップ情報を取得
            const sx = cropState.originalCropX;
            const sy = cropState.originalCropY;
            const sSize = cropState.originalCropSize;

            // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
            tempCtx.drawImage(img, sx, sy, sSize, sSize, 0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // 2. ピクセルマップをクリア
            pixelMap.clear();

            // 3. 全てのピクセルカラーをサンプリング (250x250グリッド)
            const imageData = tempCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const alpha = data[i + 3];

                // 透明度が高い（ほぼ透明）の場合はスキップ
                if (alpha < 128) {
                    continue;
                }

                const red = data[i];
                const green = data[i + 1];
                const blue = data[i + 2];

                // RGBAをHEXに変換
                const color = `#${((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1).toUpperCase()}`;

                // 座標の計算 
                const pixelIndex = i / 4;
                const c = pixelIndex % gridDimension; // 列 (x座標)
                const r = Math.floor(pixelIndex / gridDimension); // 行 (y座標)

                const key = `${c},${r}`;
                pixelMap.set(key, color);
            }

            // 4. 全体を再描画
            redrawCanvas();
            console.log(`画像をピクセル化して読み込みました。非透明ピクセル数: ${pixelMap.size}`);
            showMessage(`画像を読み込み、${pixelMap.size}個のピクセルを抽出しました。`, 'success');
        }

        /**
         * 現在のピクセルアートを左右反転します。
         */
        function flipHorizontal() {
            if (pixelMap.size === 0) {
                showMessage('ピクセルデータが空です。先に画像をアップロードしてください。', 'error');
                return;
            }

            const newPixelMap = new Map();
            const maxIndex = gridDimension - 1; // 249 (0 to 249)

            for (const [key, color] of pixelMap.entries()) {
                const [x, y] = key.split(',').map(Number);

                // 左右反転の計算: newX = (最大インデックス) - x
                const newX = maxIndex - x;
                const newKey = `${newX},${y}`;

                newPixelMap.set(newKey, color);
            }

            pixelMap = newPixelMap; // pixelMapを新しいマップで置き換え
            redrawCanvas();
            showMessage('画像を左右反転しました。', 'info');
        }

        // ----------------------------------------------------
        // データ準備と送信機能 (CORS対応のためXMLHttpRequestに変更)
        // ----------------------------------------------------

        /**
         * pixelMapのデータを250x250の一次元配列（長さ62500）に変換します。
         */
        function generatePixelArray() {
            if (pixelMap.size === 0) {
                return null;
            }

            const colorArray = [];
            const dimension = FIXED_GRID_DIMENSION; // 250

            // 行優先 (y, x) で走査し、一次元配列を生成します。
            for (let y = 0; y < dimension; y++) {
                for (let x = 0; x < dimension; x++) {
                    const key = `${x},${y}`;

                    // pixelMapに色があればそのHEXカラーコードを、なければ空文字列（透過を表現）を格納
                    const color = pixelMap.get(key) || "";
                    colorArray.push(color);
                }
            }
            return colorArray;
        }


        /**
         * GASエンドポイントにデータをPOST送信します。 (CORS対策版)
         */
        function sendDataToGAS() {
            const colorArray = generatePixelArray();

            if (!colorArray) {
                showMessage('送信するピクセルデータがありません。画像をアップロードしてください。', 'error');
                return;
            }
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "https://script.google.com/macros/s/AKfycbwDKI_-L5Asg5e4wP_vkyWkjop1VCDaFRFgY7S_J7xV5ws0o60DZAr7tWyE0BxguO3v1Q/exec");
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            const body = JSON.stringify({
                username: "-SouCraK12345-",
                image: colorArray,
                type: "upload_image",
            });
            xhr.onload = () => {
                console.log(xhr)
                if (xhr.readyState == 4 && xhr.status == 200) {
                    if (xhr.responseText == "受理完了") {
                        alert("送信に成功しました！");
                    } else {
                        alert(xhr.responseText);
                    }
                } else {
                    alert(`Error: ${xhr.status}`);
                }
            };
            xhr.onerror = () => {
                console.log(xhr)
            };
            xhr.send(body);
        }


        // ----------------------------------------------------
        // クロップ機能関連 (ロジックは前回から変更なし)
        // ----------------------------------------------------
        function showCropper(img) {
            calculateInitialCrop(img);
            drawCropperPreview();
            cropperModal.classList.remove('hidden');
        }

        function updateOriginalCropCoordinates() {
            const reverseRatio = currentImageToCrop.width / cropState.imgDraw.w;
            cropState.originalCropX = Math.round((cropState.displayCropX - cropState.imgDraw.x) * reverseRatio);
            cropState.originalCropY = Math.round((cropState.displayCropY - cropState.imgDraw.y) * reverseRatio);
            cropState.originalCropSize = Math.round(cropState.displayCropSize * reverseRatio);
        }

        function calculateInitialCrop(img) {
            const pCanvas = cropperPreviewCanvas;
            const pSize = pCanvas.width;

            let ratio = Math.min(pSize / img.width, pSize / img.height);
            let drawWidth = img.width * ratio;
            let drawHeight = img.height * ratio;
            let dx = (pSize - drawWidth) / 2;
            let dy = (pSize - drawHeight) / 2;

            cropState.imgDraw = { x: dx, y: dy, w: drawWidth, h: drawHeight, ratio: ratio };

            let cropRectSize = Math.min(drawWidth, drawHeight);
            let rectX = (pSize - cropRectSize) / 2;
            let rectY = (pSize - cropRectSize) / 2;

            cropState.displayCropX = rectX;
            cropState.displayCropY = rectY;
            cropState.displayCropSize = cropRectSize;

            updateOriginalCropCoordinates();
        }

        function drawCropperPreview() {
            const pCtx = cropperPreviewCtx;
            const pSize = cropperPreviewCanvas.width;
            const imgDraw = cropState.imgDraw;

            pCtx.clearRect(0, 0, pSize, pSize);

            if (currentImageToCrop) {
                pCtx.drawImage(currentImageToCrop, imgDraw.x, imgDraw.y, imgDraw.w, imgDraw.h);
            }

            const cropX = cropState.displayCropX;
            const cropY = cropState.displayCropY;
            const cropSize = cropState.displayCropSize;

            pCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            pCtx.fillRect(0, 0, pSize, pSize);

            pCtx.globalCompositeOperation = 'destination-out';
            pCtx.fillRect(cropX, cropY, cropSize, cropSize);
            pCtx.globalCompositeOperation = 'source-over';

            pCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            pCtx.lineWidth = 2;
            pCtx.setLineDash([5, 5]);
            pCtx.strokeRect(cropX, cropY, cropSize, cropSize);
            pCtx.setLineDash([]);
        }

        function getClientPos(e) {
            return {
                x: e.clientX || e.touches[0].clientX,
                y: e.clientY || e.touches[0].clientY
            };
        }

        function handleCropperDown(e) {
            e.preventDefault();
            if (!currentImageToCrop) return;

            const rect = cropperPreviewCanvas.getBoundingClientRect();
            const clientPos = getClientPos(e);

            const x = clientPos.x - rect.left;
            const y = clientPos.y - rect.top;

            if (x >= cropState.displayCropX && x < cropState.displayCropX + cropState.displayCropSize &&
                y >= cropState.displayCropY && y < cropState.displayCropY + cropState.displayCropSize) {

                cropState.isDragging = true;
                cropState.dragStartX = x;
                cropState.dragStartY = y;
                cropState.dragStartCropX = cropState.displayCropX;
                cropState.dragStartCropY = cropState.displayCropY;

                cropperPreviewCanvas.style.cursor = 'grabbing';
            }
        }

        function handleCropperMove(e) {
            if (!cropState.isDragging) return;
            e.preventDefault();

            const rect = cropperPreviewCanvas.getBoundingClientRect();
            const clientPos = getClientPos(e);

            const x = clientPos.x - rect.left;
            const y = clientPos.y - rect.top;

            const dx = x - cropState.dragStartX;
            const dy = y - cropState.dragStartY;

            let newX = cropState.dragStartCropX + dx;
            let newY = cropState.dragStartCropY + dy;

            const imgDraw = cropState.imgDraw;
            const cropSize = cropState.displayCropSize;

            newX = Math.max(newX, imgDraw.x);
            newX = Math.min(newX, imgDraw.x + imgDraw.w - cropSize);

            newY = Math.max(newY, imgDraw.y);
            newY = Math.min(newY, imgDraw.y + imgDraw.h - cropSize);

            cropState.displayCropX = newX;
            cropState.displayCropY = newY;

            updateOriginalCropCoordinates();

            drawCropperPreview();
        }

        function handleCropperUp() {
            if (cropState.isDragging) {
                cropState.isDragging = false;
                cropperPreviewCanvas.style.cursor = 'grab';
            }
        }


        /**
         * 画像ファイルを読み込み、正方形かどうかチェックし、必要に応じてクロッパーを表示します。
         */
        function handleImageUpload(file) {
            if (!file) return;
            showMessage('画像を読み込み中...', 'info');

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onerror = () => { showMessage('画像の読み込み中にエラーが発生しました。', 'error'); };

                img.onload = () => {
                    currentImageToCrop = img;

                    if (img.width === img.height) {
                        calculateInitialCrop(img);
                        pixelateImage(img);
                    } else {
                        showCropper(img);
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ----------------------------------------------------
        // イベントリスナー
        // ----------------------------------------------------

        // 画像アップロード
        imageUploader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleImageUpload(file);
            }
        });

        // データ送信ボタン
        sendDataButton.addEventListener('click', () => {
            sendDataToGAS();
        });

        // 左右反転ボタン
        flipHorizontalButton.addEventListener('click', () => {
            flipHorizontal();
        });

        // クロップ実行ボタン
        confirmCropButton.addEventListener('click', () => {
            if (currentImageToCrop) {
                pixelateImage(currentImageToCrop);
                cropperModal.classList.add('hidden');
                currentImageToCrop = null;
                imageUploader.value = ''; // ファイル選択をリセット
            }
        });

        // クロップキャンセルボタン
        cancelCropButton.addEventListener('click', () => {
            cropperModal.classList.add('hidden');
            currentImageToCrop = null;
            imageUploader.value = ''; // ファイル選択をリセット
            pixelMap.clear();
            redrawCanvas();
            showMessage('画像の読み込みをキャンセルしました。', 'info');
        });

        // Cropper Event Listeners (Mouse and Touch for drag)
        cropperPreviewCanvas.addEventListener('mousedown', handleCropperDown);
        window.addEventListener('mousemove', handleCropperMove);
        window.addEventListener('mouseup', handleCropperUp);
        cropperPreviewCanvas.addEventListener('touchstart', handleCropperDown, { passive: false });
        window.addEventListener('touchmove', handleCropperMove, { passive: false });
        window.addEventListener('touchend', handleCropperUp);


        // 初期化
        window.onload = () => {
            redrawCanvas();
        };
    </script>
</body>

</html>